#!/usr/bin/env python3
"""
UI component tests for GTK4/libadwaita elements
Tests responsive layout, accessibility, and user interactions
"""

import unittest
import os
from unittest.mock import Mock, patch, MagicMock
import gi

# Mock GTK imports for testing
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
gi.require_version('WebKit', '6.0')

from gi.repository import Gtk, Adw, WebKit, GLib

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))
sys.path.insert(0, os.path.dirname(__file__))  # Add tests directory for mock_gtk

from ublue_image_manager import UBlueImageWindow, UBlueImageApplication
from mock_gtk import create_mock_gtk_application, create_mock_gtk_window


@unittest.skipIf(os.environ.get('DISPLAY') is None, "No display available for GTK tests")
class TestResponsiveLayout(unittest.TestCase):
    """Test responsive UI layout behavior"""
    
    def setUp(self):
        """Set up test environment"""
        self.app = create_mock_gtk_application()
        self.window = UBlueImageWindow(self.app)
        
    def test_initial_window_size(self):
        """Test default window dimensions"""
        # Window should have default size set
        self.assertEqual(self.window.get_default_size(), (1200, 800))
        
    def test_header_bar_creation(self):
        """Test header bar is properly created"""
        self.assertIsInstance(self.window.header_bar, Adw.HeaderBar)
        
    def test_toast_overlay_setup(self):
        """Test toast overlay for notifications"""
        self.assertIsInstance(self.window.toast_overlay, Adw.ToastOverlay)
        
    @patch('gi.repository.Gtk.Window.set_default_size')
    def test_responsive_size_handling(self, mock_set_size):
        """Test window adapts to different sizes"""
        # Test mobile size
        self.window.set_default_size(400, 800)
        mock_set_size.assert_called_with(400, 800)
        
        # Test tablet size
        self.window.set_default_size(768, 1024)
        mock_set_size.assert_called_with(768, 1024)
        
        # Test desktop size
        self.window.set_default_size(1920, 1080)
        mock_set_size.assert_called_with(1920, 1080)
        
    def test_sidebar_responsive_behavior(self):
        """Test sidebar adapts to screen size"""
        # The sidebar should be created
        self.assertIsNotNone(self.window.sidebar_content)
        
        # Test that sidebar uses proper responsive container
        # In real implementation, this would check AdwLeaflet or similar
        self.assertIsInstance(self.window.sidebar_content, Gtk.Box)


@unittest.skipIf(os.environ.get('DISPLAY') is None, "No display available for GTK tests")
class TestAccessibility(unittest.TestCase):
    """Test accessibility features"""
    
    def setUp(self):
        """Set up test environment"""
        self.app = create_mock_gtk_application()
        self.window = UBlueImageWindow(self.app)
        
    def test_window_title_accessibility(self):
        """Test window has accessible title"""
        self.assertEqual(self.window.get_title(), "Universal Blue Image Manager")
        
    def test_button_accessibility_labels(self):
        """Test buttons have proper accessibility labels"""
        # Check execute mode switch
        if hasattr(self.window, 'execute_mode_switch'):
            tooltip = self.window.execute_mode_switch.get_tooltip_text()
            self.assertIsNotNone(tooltip)
            self.assertIn("mode", tooltip.lower())
            
    def test_status_rows_accessibility(self):
        """Test status rows have proper labels"""
        # Test that status rows have titles
        self.assertIsNotNone(self.window.current_image_row.get_title())
        self.assertIsNotNone(self.window.os_version_row.get_title())
        self.assertIsNotNone(self.window.deployment_row.get_title())
        
        # Verify titles are descriptive
        self.assertEqual(self.window.current_image_row.get_title(), "Current Image")
        self.assertEqual(self.window.os_version_row.get_title(), "OS Version")
        self.assertEqual(self.window.deployment_row.get_title(), "Deployment")


@unittest.skipIf(os.environ.get('DISPLAY') is None, "No display available for GTK tests")
class TestWebKitIntegration(unittest.TestCase):
    """Test WebKit WebView integration"""
    
    def setUp(self):
        """Set up test environment"""
        self.app = create_mock_gtk_application()
        self.window = UBlueImageWindow(self.app)
        
    def test_webview_creation(self):
        """Test WebView is properly created"""
        self.assertIsInstance(self.window.webview, WebKit.WebView)
        
    def test_webview_settings(self):
        """Test WebView security settings"""
        settings = self.window.webview.get_settings()
        
        # Verify security settings
        self.assertFalse(settings.get_allow_file_access_from_file_urls())
        self.assertTrue(settings.get_enable_javascript())
        
    def test_javascript_bridge_injection(self):
        """Test JavaScript bridge is injected"""
        # Verify user content manager is set up
        content_manager = self.window.webview.get_user_content_manager()
        self.assertIsNotNone(content_manager)
        
    @patch('gi.repository.WebKit.WebView.load_uri')
    def test_webview_content_loading(self, mock_load_uri):
        """Test WebView loads correct content"""
        # Verify load_uri was called
        mock_load_uri.assert_called_once()
        call_args = mock_load_uri.call_args[0]
        self.assertIn('file://', call_args[0])
        self.assertIn('index.html', call_args[0])


@unittest.skipIf(os.environ.get('DISPLAY') is None, "No display available for GTK tests")
class TestToastNotifications(unittest.TestCase):
    """Test toast notification system"""
    
    def setUp(self):
        """Set up test environment"""
        self.app = create_mock_gtk_application()
        self.window = UBlueImageWindow(self.app)
        self.window.api = Mock()
        
    @patch('gi.repository.Adw.Toast.new')
    def test_success_toast(self, mock_toast_new):
        """Test success toast notifications"""
        mock_toast = Mock()
        mock_toast_new.return_value = mock_toast
        
        # Trigger success toast
        self.window.api._show_success_toast("Operation completed")
        
        # Verify toast was created with correct message
        mock_toast_new.assert_called_with("Operation completed")
        
    @patch('gi.repository.Adw.Toast.new')
    def test_error_toast(self, mock_toast_new):
        """Test error toast notifications"""
        mock_toast = Mock()
        mock_toast_new.return_value = mock_toast
        
        # Trigger error toast
        self.window.api._show_error_toast("Operation failed")
        
        # Verify toast was created
        mock_toast_new.assert_called_with("Error: Operation failed")
        # Verify longer timeout for errors
        mock_toast.set_timeout.assert_called_with(5)
        
    def test_toast_with_action(self):
        """Test toast with action button"""
        # This would test toasts with retry/help buttons
        # Implementation depends on specific error handling
        pass


@unittest.skip("Skipping UI tests - focusing on core functionality")
class TestDialogInteractions(unittest.TestCase):
    """Test dialog user interactions"""
    
    @patch('ui.confirmation_dialog.Adw.MessageDialog')
    def test_confirmation_dialog_creation(self, mock_dialog_class):
        """Test confirmation dialog is properly created"""
        from ui.confirmation_dialog import ConfirmationDialog
        
        parent_window = Mock()
        dialog = ConfirmationDialog(parent_window)
        
        # Create a rebase confirmation
        mock_dialog = Mock()
        mock_dialog_class.new.return_value = mock_dialog
        
        dialog.show_rebase_confirmation(
            "ghcr.io/ublue-os/bluefin:latest",
            "rpm-ostree rebase ghcr.io/ublue-os/bluefin:latest",
            Mock()
        )
        
        # Verify dialog was created with parent
        mock_dialog_class.new.assert_called_once()
        call_args = mock_dialog_class.new.call_args[0]
        self.assertEqual(call_args[0], parent_window)
        self.assertIn("Rebase", call_args[1])
        
    def test_dialog_button_responses(self):
        """Test dialog button response handling"""
        from ui.confirmation_dialog import ConfirmationDialog
        
        dialog = ConfirmationDialog(Mock())
        
        # Test response callback setup
        callback_called = False
        def test_callback(response):
            nonlocal callback_called
            callback_called = True
            
        # This would test actual button clicks in a real GTK environment
        # For unit tests, we verify the structure is correct


@unittest.skipIf(os.environ.get('DISPLAY') is None, "No display available for GTK tests")
class TestExecuteModeToggle(unittest.TestCase):
    """Test execute mode toggle functionality"""
    
    def setUp(self):
        """Set up test environment"""
        self.app = create_mock_gtk_application()
        self.window = UBlueImageWindow(self.app)
        
    def test_execute_mode_switch_exists(self):
        """Test execute mode switch is created"""
        self.assertIsInstance(self.window.execute_mode_switch, Gtk.Switch)
        
    def test_execute_mode_default_state(self):
        """Test default state of execute mode"""
        # Should start in execute mode (active)
        self.assertTrue(self.window.execute_mode_switch.get_active())
        
    @patch('gi.repository.Gtk.Button.set_label')
    def test_mode_toggle_updates_buttons(self, mock_set_label):
        """Test toggling mode updates button labels"""
        # Toggle to guide mode
        self.window.execute_mode_switch.set_active(False)
        self.window.on_execute_mode_changed(self.window.execute_mode_switch, None)
        
        # Verify buttons were updated
        # In real implementation, this would check all execute buttons
        
    def test_demo_mode_disables_switch(self):
        """Test demo mode disables execute switch"""
        # Simulate demo mode status
        status = {'type': 'demo'}
        self.window.update_system_status(status)
        
        # Verify switch is disabled
        self.assertFalse(self.window.execute_mode_switch.get_sensitive())


@unittest.skip("Skipping UI tests - focusing on core functionality")
class TestProgressDisplay(unittest.TestCase):
    """Test progress display functionality"""
    
    def test_progress_panel_creation(self):
        """Test progress panel exists in web interface"""
        # This would verify the HTML contains progress elements
        # In unit tests, we verify the JavaScript injection works
        from progress_tracker import ProgressTracker
        
        api = Mock()
        api.execute_js = Mock()
        
        tracker = ProgressTracker(api)
        tracker.start_tracking("Test Operation")
        
        # Verify JavaScript was executed
        api.execute_js.assert_called()
        js_call = api.execute_js.call_args[0][0]
        self.assertIn("showProgress", js_call)
        self.assertIn("Test Operation", js_call)
        
    def test_progress_line_updates(self):
        """Test progress lines are displayed"""
        from progress_tracker import ProgressTracker
        
        api = Mock()
        api.execute_js = Mock()
        
        tracker = ProgressTracker(api)
        tracker.update_output("Processing... 50%")
        
        # Verify update was sent
        api.execute_js.assert_called()
        js_call = api.execute_js.call_args[0][0]
        self.assertIn("updateProgress", js_call)
        self.assertIn("Processing... 50%", js_call)


if __name__ == '__main__':
    unittest.main()